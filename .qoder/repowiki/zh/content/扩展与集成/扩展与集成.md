# 扩展与集成

<cite>
**本文档中引用的文件**   
- [index.md](file://docs/extensions/index.md)
- [getting-started-extensions.md](file://docs/extensions/getting-started-extensions.md)
- [extension-releasing.md](file://docs/extensions/extension-releasing.md)
- [mcp-server.md](file://docs/tools/mcp-server.md)
- [index.md](file://docs/hooks/index.md)
- [writing-hooks.md](file://docs/hooks/writing-hooks.md)
- [best-practices.md](file://docs/hooks/best-practices.md)
- [extension-manager.ts](file://packages/cli/src/config/extension-manager.ts)
- [extensionSettings.ts](file://packages/cli/src/config/extensions/extensionSettings.ts)
- [hookSystem.ts](file://packages/core/src/hooks/hookSystem.ts)
</cite>

## 目录
1. [MCP服务器](#mcp服务器)
2. [自定义扩展](#自定义扩展)
3. [Hook系统](#hook系统)

## MCP服务器

Model Context Protocol (MCP) 服务器是将工具和资源通过标准化协议暴露给 Gemini CLI 的应用程序，充当 Gemini 模型与本地环境或外部服务（如API）之间的桥梁。通过 MCP 服务器，Gemini CLI 能够发现、执行工具并访问资源，从而扩展其内置功能，执行与数据库、API、自定义脚本或特定工作流交互等操作。

### MCP 工作原理

MCP 服务器通过一个发现和执行系统与 Gemini CLI 集成。该过程始于 CLI 启动时，对 `settings.json` 文件中配置的每个 MCP 服务器执行以下步骤：

1.  **连接建立**：根据配置（`httpUrl`、`url` 或 `command`），CLI 选择适当的传输机制（流式 HTTP、SSE 或 Stdio）并尝试连接。
2.  **工具发现**：连接成功后，CLI 会调用服务器的工具列表端点来获取所有可用工具的定义。
3.  **模式处理**：获取的工具模式会经过清理和验证，以确保与 Gemini API 兼容。这包括移除 `$schema` 和 `additionalProperties` 属性，并对工具名称进行消毒（替换无效字符，处理名称冲突）。
4.  **注册与冲突解决**：工具被注册到全局工具注册表中。如果多个服务器暴露了同名工具，第一个注册的服务器获得无前缀的名称，后续服务器的工具名称将被自动加上服务器名前缀（例如 `serverName__toolName`）。
5.  **连接管理**：成功注册工具的服务器将保持连接，而未提供可用工具的服务器连接将被关闭。

当模型决定使用一个 MCP 工具时，会触发执行流程：
1.  **调用**：模型生成一个 `FunctionCall`，包含工具名和参数。
2.  **确认**：根据服务器的 `trust` 设置和用户的确认选择，决定是否需要用户确认。如果服务器被信任（`trust: true`），则跳过确认。
3.  **执行**：在获得确认或信任后，CLI 通过底层传输机制调用 MCP 服务器。
4.  **响应处理**：服务器的响应被处理，分为供语言模型使用的上下文内容（`llmContent`）和供用户查看的格式化输出（`returnDisplay`）。

### 配置和使用 MCP 服务器

MCP 服务器的配置在 `settings.json` 文件中完成，主要通过 `mcpServers` 对象进行。

#### 配置结构

```json
{
  "mcpServers": {
    "serverName": {
      "command": "path/to/server",
      "args": ["--arg1", "value1"],
      "env": {
        "API_KEY": "$MY_API_TOKEN"
      },
      "cwd": "./server-directory",
      "timeout": 30000,
      "trust": false
    }
  }
}
```

#### 配置属性

-   **必需属性（三选一）**:
    -   `command` (string): 用于 Stdio 传输的可执行文件路径。
    -   `url` (string): SSE 端点 URL (例如 `"http://localhost:8080/sse"`)。
    -   `httpUrl` (string): 流式 HTTP 端点 URL。
-   **可选属性**:
    -   `args` (string[]): 用于 Stdio 传输的命令行参数。
    -   `headers` (object): 使用 `url` 或 `httpUrl` 时的自定义 HTTP 头。
    -   `env` (object): 服务器进程的环境变量。值可以使用 `$VAR_NAME` 或 `${VAR_NAME}` 语法引用环境变量。
    -   `cwd` (string): Stdio 传输的工作目录。
    -   `timeout` (number): 请求超时时间（毫秒，默认 600,000ms = 10 分钟）。
    -   `trust` (boolean): 为 `true` 时，绕过此服务器的所有工具调用确认（默认 `false`）。**安全提示**：仅对完全受控的服务器使用此选项。
    -   `includeTools` (string[]): 从此 MCP 服务器包含的工具名称列表（白名单行为）。
    -   `excludeTools` (string[]): 从此 MCP 服务器排除的工具名称列表。**注意**：`excludeTools` 优先于 `includeTools`。

#### 定义自定义工具

MCP 服务器使用 `@modelcontextprotocol/sdk` SDK 来定义工具。一个工具需要一个名称、描述和输入模式（使用 `zod` 库定义），以及一个执行函数。

```typescript
server.registerTool(
  'fetch_posts',
  {
    description: '从公共API获取帖子列表。',
    inputSchema: z.object({}).shape,
  },
  async () => {
    const apiResponse = await fetch('https://jsonplaceholder.typicode.com/posts');
    const posts = await apiResponse.json();
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({ posts: posts.slice(0, 5) }),
        },
      ],
    };
  }
);
```

#### 处理请求/响应

MCP 服务器通过其传输机制（如 `StdioServerTransport`）接收请求并发送响应。请求包含工具名称和参数，服务器执行相应逻辑后，返回一个包含 `content` 数组的 `CallToolResult` 对象。`content` 数组可以包含文本、图像、音频等多种类型的内容块，这些内容将作为上下文提供给模型进行后续推理。

**Section sources**
- [mcp-server.md](file://docs/tools/mcp-server.md#L1-L1045)
- [example.ts](file://packages/cli/src/commands/extensions/examples/mcp-server/example.ts#L1-L61)

## 自定义扩展

自定义扩展是将提示、MCP 服务器和自定义命令打包成一个熟悉且用户友好的格式的包。通过扩展，可以扩展 Gemini CLI 的功能并与其他用户共享。

### 创建和安装扩展包

#### 目录结构

一个扩展包是一个包含 `gemini-extension.json` 文件的目录。其典型结构如下：

```
my-extension/
├── gemini-extension.json
├── GEMINI.md (可选)
├── commands/ (可选)
│   └── my-command.toml
├── hooks/ (可选)
│   └── hooks.json
└── mcp-servers/ (可选)
    └── server.js
```

#### 配置文件 (gemini-extension.json)

`gemini-extension.json` 是扩展的清单文件，其结构如下：

```json
{
  "name": "my-extension",
  "version": "1.0.0",
  "mcpServers": {
    "my-server": {
      "command": "node my-server.js"
    }
  },
  "contextFileName": "GEMINI.md",
  "excludeTools": ["run_shell_command"]
}
```

-   `name` (string): 扩展的唯一名称，用于标识和冲突解决。
-   `version` (string): 扩展的版本。
-   `mcpServers` (object): MCP 服务器的映射。键是服务器名称，值是服务器配置。这些服务器会在启动时加载。
-   `contextFileName` (string or array): 包含扩展上下文的文件名。如果未指定但存在 `GEMINI.md` 文件，则会加载该文件。
-   `excludeTools` (array): 要从模型中排除的工具名称数组。
-   `settings` (array): 定义扩展设置，用户在安装时会被提示提供。

#### 安装扩展

使用 `gemini extensions install` 命令安装扩展：

```bash
gemini extensions install <source> [--ref <ref>] [--auto-update] [--pre-release] [--consent]
```

-   `<source>`: 扩展的 GitHub URL 或本地路径。
-   `--ref`: 要安装的 git ref。
-   `--auto-update`: 为此扩展启用自动更新。
-   `--pre-release`: 为此扩展启用预发布版本。
-   `--consent`: 确认安装扩展的安全风险并跳过确认提示。

#### 创建扩展

可以使用内置模板快速创建新扩展：

```bash
gemini extensions new <path> [template]
```

例如，使用 `mcp-server` 模板创建一个新扩展：

```bash
gemini extensions new my-first-extension mcp-server
```

#### 链接本地扩展

`gemini extensions link` 命令会在扩展安装目录和开发路径之间创建一个符号链接，这样在开发时无需每次更新。

```bash
gemini extensions link .
```

**Section sources**
- [index.md](file://docs/extensions/index.md#L1-L294)
- [getting-started-extensions.md](file://docs/extensions/getting-started-extensions.md#L1-L246)
- [extension-releasing.md](file://docs/extensions/extension-releasing.md#L1-L184)
- [extension-manager.ts](file://packages/cli/src/config/extension-manager.ts#L1-L820)

## Hook系统

Hook 系统允许在 Gemini CLI 的智能体循环中的特定点执行脚本或程序，从而在不修改 CLI 源代码的情况下拦截和自定义行为。

### 可用的 Hook 事件

| 事件 | 触发时机 | 常见用例 |
| :--- | :--- | :--- |
| `SessionStart` | 会话开始时 | 初始化资源，加载上下文 |
| `SessionEnd` | 会话结束时 | 清理，保存状态 |
| `BeforeAgent` | 用户提交提示后，规划前 | 添加上下文，验证提示 |
| `AfterAgent` | 智能体循环结束时 | 审查输出，强制继续 |
| `BeforeModel` | 发送请求到 LLM 之前 | 修改提示，添加指令 |
| `AfterModel` | 收到 LLM 响应后 | 过滤响应，记录交互 |
| `BeforeToolSelection` | LLM 选择工具前（在 BeforeModel 之后） | 过滤可用工具，优化选择 |
| `BeforeTool` | 工具执行前 | 验证参数，阻止危险操作 |
| `AfterTool` | 工具执行后 | 处理结果，运行测试 |
| `PreCompress` | 上下文压缩前 | 保存状态，通知用户 |
| `Notification` | 发生通知时（例如，权限） | 自动批准，记录决策 |

### 编写 Hook 脚本

Hook 脚本通过标准输入（stdin）接收 JSON 格式的输入，并通过退出码和标准输出（stdout）/标准错误（stderr）进行通信。

#### 通信契约

-   **输入**：JSON 格式，通过 stdin。
-   **输出**：退出码 + stdout/stderr。
-   **退出码**：
    -   `0`：成功 - stdout 显示给用户（或作为上下文注入）。
    -   `2`：阻塞错误 - stderr 显示给智能体/用户，操作可能被阻止。
    -   其他：非阻塞警告 - 记录但执行继续。

#### 示例：阻止包含秘密的写入

以下是一个在 `BeforeTool` 事件中阻止写入包含 API 密钥或密码的文件的 Hook 脚本示例。

**`.gemini/hooks/block-secrets.sh`**:
```bash
#!/usr/bin/env bash
input=$(cat)

# 提取要写入的内容
content=$(echo "$input" | jq -r '.tool_input.content // .tool_input.new_string // ""')

# 检查是否包含秘密
if echo "$content" | grep -qE 'api[_-]?key|password|secret'; then
  echo '{"decision":"deny","reason":"检测到潜在秘密"}' >&2
  exit 2
fi

exit 0
```

**`.gemini/settings.json`**:
```json
{
  "hooks": {
    "BeforeTool": [
      {
        "matcher": "WriteFile|Edit",
        "hooks": [
          {
            "name": "secret-scanner",
            "type": "command",
            "command": "$GEMINI_PROJECT_DIR/.gemini/hooks/block-secrets.sh",
            "description": "防止提交秘密"
          }
        ]
      }
    ]
  }
}
```

### 安全最佳实践

1.  **验证所有输入**：永远不要信任来自 Hook 的数据，始终验证 JSON 结构和所需字段。
2.  **使用超时**：为 Hook 设置合理的超时时间，以防止其无限期挂起。
3.  **限制权限**：以最低权限运行 Hook 脚本，避免以 root 身份运行。
4.  **扫描秘密**：使用 `BeforeTool` Hook 防止在代码中提交 API 密钥、密码等敏感信息。
5.  **审查外部脚本**：在启用来自不受信任来源的 Hook 脚本之前，务必先审查其代码。
6.  **沙箱化不受信任的 Hook**：对于最大安全性，考虑在隔离环境（如 Docker 容器）中运行不受信任的 Hook。

**Section sources**
- [index.md](file://docs/hooks/index.md#L1-L561)
- [writing-hooks.md](file://docs/hooks/writing-hooks.md#L1-L1027)
- [best-practices.md](file://docs/hooks/best-practices.md#L1-L807)
- [hookSystem.ts](file://packages/core/src/hooks/hookSystem.ts#L1-L107)